# -*- mode: org; fill-column: 78; -*-
# Time-stamp: <2023-06-05 22:01:13 krylon>
#
#+TAGS: optimize(o) refactor(r) bug(b) feature(f) architecture(a)
#+TAGS: web(w) database(d) javascript(j) ui(u)
#+TODO: TODO(t) IMPLEMENT(i) TEST(e) RESEARCH(r) | DONE(d)
#+TODO: MEDITATE(m) PLANNING(p) REFINE(n) | FAILED(f) CANCELLED(c) SUSPENDED(s)
#+TODO: EXPERIMENT(x) |
#+PRIORITIES: A G D

* uptimed
  Uptimed is an application to keep track of the uptime and system load of
  several systems and watch the recorded data in a web interface.
** Clocktable
   #+BEGIN: clocktable :scope file :maxlevel 20
   #+CAPTION: Clock summary at [2023-06-05 Mo 22:01]
   | Headline             | Time    |       |       |      |
   |----------------------+---------+-------+-------+------|
   | *Total time*         | *23:45* |       |       |      |
   |----------------------+---------+-------+-------+------|
   | uptimed              | 23:45   |       |       |      |
   | \_  Components [0/0] |         | 23:45 |       |      |
   | \_    Database [0/0] |         |       |  4:43 |      |
   | \_    Server [1/2]   |         |       | 16:47 |      |
   | \_      Graphing     |         |       |       | 3:37 |
   | \_    Client [0/1]   |         |       |  2:15 |      |
   #+END:
** Components [0/0]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
*** Database [0/0]
    :PROPERTIES:
    :COOKIE_DATA: todo recursive
    :VISIBILITY: children
    :END:
    :LOGBOOK:
    CLOCK: [2023-06-02 Fr 17:57]--[2023-06-02 Fr 17:58] =>  0:01
    CLOCK: [2023-06-02 Fr 16:40]--[2023-06-02 Fr 16:59] =>  0:19
    CLOCK: [2023-06-02 Fr 10:12]--[2023-06-02 Fr 10:51] =>  0:39
    CLOCK: [2023-06-02 Fr 09:35]--[2023-06-02 Fr 10:00] =>  0:25
    CLOCK: [2023-06-01 Do 18:33]--[2023-06-01 Do 21:52] =>  3:19
    :END:
    I'm not sure I want to use SQLite *again*, maybe I should give nutsdb a
    try. It has transactions, runs embedded, and it's written in pure Go.
    On the other hand, SQLite just works, and it takes care of so many
    problems.
    *sigh* I'm going to use SQLite. There is no reason /not/ to use it,
    really.
*** Server [1/2]                                                        :web:
    :PROPERTIES:
    :COOKIE_DATA: todo recursive
    :VISIBILITY: children
    :END:
    :LOGBOOK:
    CLOCK: [2023-06-05 Mo 16:54]--[2023-06-05 Mo 17:37] =>  0:43
    CLOCK: [2023-06-05 Mo 09:56]--[2023-06-05 Mo 12:25] =>  2:29
    CLOCK: [2023-06-03 Sa 20:48]--[2023-06-03 Sa 23:22] =>  2:34
    CLOCK: [2023-06-03 Sa 16:24]--[2023-06-03 Sa 20:22] =>  3:58
    CLOCK: [2023-06-02 Fr 19:22]--[2023-06-02 Fr 21:32] =>  2:10
    CLOCK: [2023-06-02 Fr 17:58]--[2023-06-02 Fr 19:14] =>  1:16
    :END:
    I'm going to use a web server both for the frontend and for the
    client-server communication. I'll need the web server anyway, might as
    well use it for the clients instead of hand-rolling some half-baked
    protocol myself.
**** TODO Compression
     HTTP allows compression of content, I will look into that.
**** DONE Graphing                                                       :ui:
     CLOSED: [2023-06-05 Mo 22:00]
     :LOGBOOK:
     CLOCK: [2023-06-05 Mo 21:20]--[2023-06-05 Mo 22:00] =>  0:40
     CLOCK: [2023-06-05 Mo 19:40]--[2023-06-05 Mo 21:11] =>  1:31
     CLOCK: [2023-06-05 Mo 17:57]--[2023-06-05 Mo 19:23] =>  1:26
     :END:
     I want to create beautiful charts, so I'm going to look first for a Go
     library to render time series charts.
*** Client [0/1]
    :PROPERTIES:
    :COOKIE_DATA: todo recursive
    :VISIBILITY: children
    :END:
    :LOGBOOK:
    CLOCK: [2023-06-04 So 17:21]--[2023-06-04 So 19:36] =>  2:15
    :END:
    The client should be relatively straightforward, I think. I'm going to
    start here and work on gathering the data required.
**** TODO Offline buffering
** Bugs [0/0]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
** Notes
